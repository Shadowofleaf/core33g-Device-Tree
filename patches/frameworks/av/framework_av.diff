diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
index 7e92c34..ad1a87a 100644
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -54,7 +54,7 @@ extern const char *MEDIA_MIMETYPE_CONTAINER_MATROSKA;
 extern const char *MEDIA_MIMETYPE_CONTAINER_MPEG2TS;
 extern const char *MEDIA_MIMETYPE_CONTAINER_AVI;
 extern const char *MEDIA_MIMETYPE_CONTAINER_MPEG2PS;
-
+extern const char *MEDIA_MIMETYPE_CONTAINER_FLV;
 extern const char *MEDIA_MIMETYPE_CONTAINER_WVM;
 
 extern const char *MEDIA_MIMETYPE_TEXT_3GPP;
diff --git a/media/libstagefright/AVIExtractor.cpp b/media/libstagefright/AVIExtractor.cpp
index 299c40c..d5ad175 100644
--- a/media/libstagefright/AVIExtractor.cpp
+++ b/media/libstagefright/AVIExtractor.cpp
@@ -35,6 +35,13 @@
 
 namespace android {
 
+enum {
+    WAVE_FORMAT_PCM = 1,
+    WAVE_FORMAT_ALAW = 6,
+    WAVE_FORMAT_MULAW = 7,
+    WAVE_FORMAT_IMAADPCM = 0x11
+};
+
 struct AVIExtractor::AVISource : public MediaSource {
     AVISource(const sp<AVIExtractor> &extractor, size_t trackIndex);
 
@@ -69,6 +76,7 @@ struct AVIExtractor::MP3Splitter : public RefBase {
     void clear();
     void append(MediaBuffer *buffer);
     status_t read(MediaBuffer **buffer);
+    status_t readparam(int type, int16_t &param_value);
 
 protected:
     virtual ~MP3Splitter();
@@ -77,6 +85,7 @@ struct AVIExtractor::MP3Splitter : public RefBase {
     bool mFindSync;
     int64_t mBaseTimeUs;
     int64_t mNumSamplesRead;
+    int16_t nChannelnum;
     sp<ABuffer> mBuffer;
 
     bool resync();
@@ -105,8 +114,14 @@ status_t AVIExtractor::AVISource::start(MetaData *params) {
 
     mBufferGroup = new MediaBufferGroup;
 
-    mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxSampleSize));
-    mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxSampleSize));
+    if(8 == mTrack.mBitsPerSample) {
+        mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxSampleSize<<1));
+        mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxSampleSize<<1));
+    } else {
+        mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxSampleSize));
+        mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxSampleSize));
+    }
+
     mSampleIndex = 0;
 
     const char *mime;
@@ -144,7 +159,8 @@ status_t AVIExtractor::AVISource::read(
 
     int64_t seekTimeUs;
     ReadOptions::SeekMode seekMode;
-    if (options && options->getSeekTo(&seekTimeUs, &seekMode)) {
+    if (options && options->getSeekTo(&seekTimeUs, &seekMode)
+        && mExtractor->mIndexType != NO_INDEX) {
         status_t err =
             mExtractor->getSampleIndexAtTime(
                     mTrackIndex, seekTimeUs, seekMode, &mSampleIndex);
@@ -158,15 +174,33 @@ status_t AVIExtractor::AVISource::read(
         }
     }
 
-    for (;;) {
+    for (int i=0;; i++) {
         if (mSplitter != NULL) {
             status_t err = mSplitter->read(buffer);
 
             if (err == OK) {
+		int16_t channel_data = 0;
+		int32_t channel_data_old = 0;
+		mSplitter->readparam(0 , channel_data);
+
+		mTrack.mMeta->findInt32(kKeyChannelCount, &channel_data_old);
+		if ( channel_data_old != channel_data)
+		{
+			mTrack.mMeta->setInt32(kKeyChannelCount, channel_data);
+		}
                 break;
             } else if (err != -EAGAIN) {
                 return err;
             }
+            else  /* (err == -EAGAIN) */
+            {
+                if( i>100)
+                {
+                    // to avoid dead loop.
+                    ALOGE("AVIExtractor, mSplitter read() failed > 100 times, stop. \n");
+                    return ERROR_END_OF_STREAM;
+                }
+            }
         }
 
         off64_t offset;
@@ -179,19 +213,52 @@ status_t AVIExtractor::AVISource::read(
         ++mSampleIndex;
 
         if (err != OK) {
-            return ERROR_END_OF_STREAM;
+            if( mSampleIndex < mTrack.mSamples.size() ) {
+                continue;
+            } else {
+                return ERROR_END_OF_STREAM;
+            }
         }
 
         MediaBuffer *out;
         CHECK_EQ(mBufferGroup->acquire_buffer(&out), (status_t)OK);
 
+        if(size > mTrack.mMaxSampleSize)
+        {
+            size = mTrack.mMaxSampleSize;//buffer is not enough
+        }
         ssize_t n = mExtractor->mDataSource->readAt(offset, out->data(), size);
 
         if (n < (ssize_t)size) {
             return n < 0 ? (status_t)n : (status_t)ERROR_MALFORMED;
         }
 
-        out->set_range(0, size);
+        const char *mime;
+        CHECK(mTrack.mMeta->findCString(kKeyMIMEType, &mime));
+
+        if ( !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)  && (mTrack.mBitsPerSample == 8)) {
+            // Convert 8-bit unsigned samples to 16-bit signed.
+            MediaBuffer *tmp;
+            CHECK_EQ(mBufferGroup->acquire_buffer(&tmp), (status_t)OK);
+
+            // The new buffer holds the sample number of samples, but each
+            // one is 2 bytes wide.
+            tmp->set_range(0, 2 * n);
+
+            int16_t *dst = (int16_t *)tmp->data();
+            const uint8_t *src = (const uint8_t *)out->data();
+            ssize_t numBytes = n;
+
+            while (numBytes-- > 0) {
+                *dst++ = ((int16_t)(*src) - 128) * 256;
+                ++src;
+            }
+
+            out->release();
+            out = tmp;
+        }else {
+            out->set_range(0, size);
+        }
 
         out->meta_data()->setInt64(kKeyTime, timeUs);
 
@@ -338,10 +405,13 @@ status_t AVIExtractor::MP3Splitter::read(MediaBuffer **out) {
     size_t frameSize;
     int sampleRate;
     int numSamples;
+    int channel_mode;
     if (!GetMPEGAudioFrameSize(
-                header, &frameSize, &sampleRate, NULL, NULL, &numSamples)) {
-        return ERROR_MALFORMED;
+                header, &frameSize, &sampleRate, &channel_mode, NULL, &numSamples)) {
+        clear();
+        return -EAGAIN;
     }
+   nChannelnum = channel_mode ;
 
     if (mBuffer->size() < frameSize) {
         return -EAGAIN;
@@ -363,6 +433,14 @@ status_t AVIExtractor::MP3Splitter::read(MediaBuffer **out) {
     return OK;
 }
 
+status_t AVIExtractor::MP3Splitter::readparam(int type,int16_t & param_value)
+{
+    param_value = nChannelnum;
+
+   return	OK;
+
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 
 AVIExtractor::AVIExtractor(const sp<DataSource> &dataSource)
@@ -400,19 +478,94 @@ sp<MetaData> AVIExtractor::getMetaData() {
     return meta;
 }
 
+uint32_t AVIExtractor::flags() const {
+    if(mIndexType == NO_INDEX) //don't support seek if no index in broken files
+    {
+        return CAN_PAUSE;
+    }
+    else
+    {
+        return MediaExtractor::flags();
+    }
+}
+
+
 status_t AVIExtractor::parseHeaders() {
     mTracks.clear();
     mMovieOffset = 0;
     mFoundIndex = false;
     mOffsetsAreAbsolute = false;
+    mIndexType = NO_INDEX;
 
-    ssize_t res = parseChunk(0ll, -1ll);
+    //ssize_t res = parseChunk(0ll, -1ll);
+    off64_t dataSize = 0;
+    status_t err = mDataSource->getSize(&dataSize);
+    if(err == ERROR_UNSUPPORTED)
+    {
+        dataSize = -1;
+    }
+    else if(err != OK)
+    {
+        return err;
+    }
+
+    ssize_t res = parseChunk(0ll, dataSize);
 
     if (res < 0) {
         return (status_t)res;
     }
 
-    if (mMovieOffset == 0ll || !mFoundIndex) {
+    if(mIndexType == NO_INDEX)
+    {
+        ALOGV("NO index existed!");
+        mOffsetsAreAbsolute = true;
+        //init all track's first sample position to movi's first sample position.
+        for (size_t i = 0; i < mTracks.size(); ++i) {
+            Track *track = &mTracks.editItemAt(i);
+            track->mCurSamplePos = mMovieOffset + 12;
+        }
+    }
+    //cut from parseindex()
+    for (size_t i = 0; i < mTracks.size(); ++i) {
+        Track *track = &mTracks.editItemAt(i);
+        const char *tmp;
+        CHECK(track->mMeta->findCString(kKeyMIMEType, &tmp));
+
+        AString mime = tmp;
+
+        if (!strncasecmp("video/", mime.c_str(), 6)) {
+            if (track->mThumbnailSampleIndex >= 0) {
+                int64_t thumbnailTimeUs;
+
+                if ((status_t)OK !=
+                        (err = getSampleTime(i, track->mThumbnailSampleIndex,
+                                             &thumbnailTimeUs))) {
+                    ALOGE("getSampleTime failed(%d)", err);
+                    return err;
+                }
+
+                track->mMeta->setInt64(kKeyThumbnailTime, thumbnailTimeUs);
+            }
+
+            err = OK;
+
+            if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_VIDEO_MPEG4)) {
+                if( OK != addMPEG4CodecSpecificData(i) )
+                {
+                    ALOGE("parseHeaders, addMPEG4CodecSpecificData failed, trackidx=%d",i);
+                }
+                
+            } else if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_VIDEO_AVC)) {
+                err = addH264CodecSpecificData(i);
+            }
+
+            if (err != OK) {
+                return err;
+            }
+        }
+    }
+
+    if (mMovieOffset == 0ll/* || !mFoundIndex*/) {
         return ERROR_MALFORMED;
     }
 
@@ -435,7 +588,8 @@ ssize_t AVIExtractor::parseChunk(off64_t offset, off64_t size, int depth) {
     uint32_t chunkSize = U32LE_AT(&tmp[4]);
 
     if (size >= 0 && chunkSize + 8 > size) {
-        return ERROR_MALFORMED;
+        //return ERROR_MALFORMED;
+        chunkSize = size - 8;
     }
 
     static const char kPrefix[] = "                              ";
@@ -511,7 +665,18 @@ ssize_t AVIExtractor::parseChunk(off64_t offset, off64_t size, int depth) {
 
             case FOURCC('i', 'd', 'x', '1'):
             {
-                err = parseIndex(offset + 8, chunkSize);
+                if(mIndexType == NO_INDEX) //IF indx found, don't care idx1
+                {
+                    err = parseIdx1(offset + 8, chunkSize);
+                    mIndexType = IDX1;
+                }
+                break;
+            }
+            case FOURCC('i', 'n', 'd', 'x'):
+            {
+                //don't check return values, since broken file may miss some std index
+                parseIndx(offset, chunkSize + 8);
+                mIndexType = INDX;
                 break;
             }
 
@@ -519,6 +684,13 @@ ssize_t AVIExtractor::parseChunk(off64_t offset, off64_t size, int depth) {
                 break;
         }
 
+        if(((tmp[0] == 'i') && tmp[1] == 'x') ||
+           ((tmp[2] == 'i') && tmp[3] == 'x'))
+        {
+            parseIndx(offset, chunkSize + 8);
+            mIndexType = INDX;
+        }
+
         if (err != OK) {
             return err;
         }
@@ -571,16 +743,23 @@ static const char *GetMIMETypeForHandler(uint32_t handler) {
         case FOURCC('X', 'v', 'i', 'D'):
         case FOURCC('x', 'v', 'i', 'd'):
         case FOURCC('X', 'V', 'I', 'X'):
+        case FOURCC('f', 'f', 'd', 's'):
+        case FOURCC('y','v','1','2'):
             return MEDIA_MIMETYPE_VIDEO_MPEG4;
 
         // from http://wiki.multimedia.cx/index.php?title=H264
         case FOURCC('a', 'v', 'c', '1'):
         case FOURCC('d', 'a', 'v', 'c'):
         case FOURCC('x', '2', '6', '4'):
+        case FOURCC('h', '2', '6', '4'):
         case FOURCC('H', '2', '6', '4'):
         case FOURCC('v', 's', 's', 'h'):
             return MEDIA_MIMETYPE_VIDEO_AVC;
 
+        case FOURCC('h', '2', '6', '3'):
+        case FOURCC('H', '2', '6', '3'):
+            return MEDIA_MIMETYPE_VIDEO_H263;
+
         case FOURCC('m', 'j', 'p', 'g'):
         case FOURCC('M', 'J', 'P', 'G'):
             return MEDIA_MIMETYPE_VIDEO_MJPG;
@@ -616,11 +795,13 @@ status_t AVIExtractor::parseStreamHeader(off64_t offset, size_t size) {
 
     uint32_t rate = U32LE_AT(&data[20]);
     uint32_t scale = U32LE_AT(&data[24]);
+    uint32_t length = U32LE_AT(&data[32]);
 
     uint32_t sampleSize = U32LE_AT(&data[44]);
 
     const char *mime = NULL;
     Track::Kind kind = Track::OTHER;
+    int32_t maxSampleSize = 0;
 
     if (type == FOURCC('v', 'i', 'd', 's')) {
         mime = GetMIMETypeForHandler(handler);
@@ -638,12 +819,14 @@ status_t AVIExtractor::parseStreamHeader(off64_t offset, size_t size) {
         }
 
         kind = Track::VIDEO;
+        maxSampleSize = AVI_VIDEO_SAMPLE_MAX_SIZE;
     } else if (type == FOURCC('a', 'u', 'd', 's')) {
         if (mime && strncasecmp(mime, "audio/", 6)) {
             return ERROR_MALFORMED;
         }
 
         kind = Track::AUDIO;
+        maxSampleSize = AVI_AUDIO_SAMPLE_MAX_SIZE;
     }
 
     if (!mime) {
@@ -652,6 +835,18 @@ status_t AVIExtractor::parseStreamHeader(off64_t offset, size_t size) {
 
     meta->setCString(kKeyMIMEType, mime);
 
+    //set duration and maxsamplesize first anyway, may be changed in parseIndex()
+    if(scale ==0)
+    {
+        scale = 1;
+    }
+    if(rate ==0)
+    {
+        rate = 1;
+    }
+    meta->setInt64(kKeyDuration, (int64_t)(length * 1000000ll * rate / scale));
+    meta->setInt32(kKeyMaxInputSize, maxSampleSize);
+
     mTracks.push();
     Track *track = &mTracks.editItemAt(mTracks.size() - 1);
 
@@ -663,9 +858,11 @@ status_t AVIExtractor::parseStreamHeader(off64_t offset, size_t size) {
     track->mNumSyncSamples = 0;
     track->mThumbnailSampleSize = 0;
     track->mThumbnailSampleIndex = -1;
-    track->mMaxSampleSize = 0;
+    track->mMaxSampleSize = maxSampleSize;
     track->mAvgChunkSize = 1.0;
     track->mFirstChunkSize = 0;
+    track->mCurSamplePos = 0;
+    track->mBitsPerSample = 0;
 
     return OK;
 }
@@ -699,22 +896,70 @@ status_t AVIExtractor::parseStreamFormat(off64_t offset, size_t size) {
     const uint8_t *data = buffer->data();
 
     if (isVideo) {
+        const char *mime = NULL;
         uint32_t width = U32LE_AT(&data[4]);
         uint32_t height = U32LE_AT(&data[8]);
+        uint32_t handler = U32_AT(&data[16]);
+ 
+        mime = GetMIMETypeForHandler(handler);
+        if ((!mime)||(mime && strncasecmp(mime, "video/", 6))) {
+            ALOGI("strh Unsupported video format '%c%c%c%c'",
+                 (char)(handler >> 24),
+                 (char)((handler >> 16) & 0xff),
+                 (char)((handler >> 8) & 0xff),
+                 (char)(handler & 0xff));
+        }else{
+            track->mMeta->setCString(kKeyMIMEType, mime);
+        }
 
         track->mMeta->setInt32(kKeyWidth, width);
         track->mMeta->setInt32(kKeyHeight, height);
     } else {
         uint32_t format = U16LE_AT(data);
-
-        if (format == 0x55) {
-            track->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG);
-        } else {
-            ALOGW("Unsupported audio format = 0x%04x", format);
-        }
-
         uint32_t numChannels = U16LE_AT(&data[2]);
         uint32_t sampleRate = U32LE_AT(&data[4]);
+        uint32_t blockAlign = U16LE_AT(&data[12]);
+        uint32_t bitsPerSample = U16LE_AT(&data[14]);
+
+        switch(format){
+            case 0x55:
+            case 0x50:
+                track->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG);
+                break;
+            case WAVE_FORMAT_PCM:
+                if( (16 == bitsPerSample) || (8 == bitsPerSample) ){
+                    track->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
+                    track->mBitsPerSample = bitsPerSample;
+                }else{
+                    ALOGW("Unsupported WAVE_FORMAT_PCM but wrong bits = %d", bitsPerSample);
+                }
+                break;
+            case WAVE_FORMAT_ALAW:
+                if(8 == bitsPerSample){
+                    track->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_G711_ALAW);
+                 }else{
+                    ALOGW("Unsupported WAVE_FORMAT_ALAW but wrong bits = %d", bitsPerSample);
+                }
+                break;
+            case WAVE_FORMAT_MULAW:
+                if(8 == bitsPerSample){
+                    track->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_G711_MLAW);
+                }else{
+                    ALOGW("Unsupported WAVE_FORMAT_MULAW but wrong bits = %d", bitsPerSample);
+                }
+                break;
+            case WAVE_FORMAT_IMAADPCM:
+                if(4 == bitsPerSample){
+                    track->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_IMAADPCM);
+                    track->mMeta->setInt32(kKeyBlockAlign, blockAlign);
+                }else{
+                    ALOGW("Unsupported WAVE_FORMAT_IMAADPCM but wrong bits = 0x%04x", bitsPerSample);
+                }
+                break;
+             default:
+                ALOGW("Unsupported audio format = 0x%04x", format);
+                break;
+        };
 
         track->mMeta->setInt32(kKeyChannelCount, numChannels);
         track->mMeta->setInt32(kKeySampleRate, sampleRate);
@@ -732,6 +977,7 @@ bool AVIExtractor::IsCorrectChunkType(
         case Track::VIDEO:
         {
             if (chunkBase != FOURCC(0, 0, 'd', 'c')
+                    && chunkBase != FOURCC(0, 0, 's', 'b')
                     && chunkBase != FOURCC(0, 0, 'd', 'b')) {
                 return false;
             }
@@ -768,28 +1014,30 @@ bool AVIExtractor::IsCorrectChunkType(
     return true;
 }
 
-status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
-    if ((size % 16) != 0) {
+status_t AVIExtractor::parseIdx1(off64_t offset, size_t size) {
+    /*if ((size % 16) != 0) {
         return ERROR_MALFORMED;
-    }
+    }*/
 
     sp<ABuffer> buffer = new ABuffer(size);
     ssize_t n = mDataSource->readAt(offset, buffer->data(), buffer->size());
 
     if (n < (ssize_t)size) {
-        return n < 0 ? (status_t)n : ERROR_MALFORMED;
+        //return n < 0 ? (status_t)n : ERROR_MALFORMED;
     }
-
     const uint8_t *data = buffer->data();
 
-    while (size > 0) {
+    while (n >= 16) {
         uint32_t chunkType = U32_AT(data);
 
         uint8_t hi = chunkType >> 24;
         uint8_t lo = (chunkType >> 16) & 0xff;
 
         if (hi < '0' || hi > '9' || lo < '0' || lo > '9') {
-            return ERROR_MALFORMED;
+//            return ERROR_MALFORMED;
+            data += 16;
+            n -= 16;
+            continue;
         }
 
         size_t trackIndex = 10 * (hi - '0') + (lo - '0');
@@ -806,7 +1054,7 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
 
         if (track->mKind == Track::OTHER) {
             data += 16;
-            size -= 16;
+            n -= 16;
             continue;
         }
 
@@ -825,6 +1073,15 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
 
         info->mOffset = offset;
         info->mIsKey = (flags & 0x10) != 0;
+        
+        if(track->mSamples.size() > 1){
+            track->mLengthTotal += track->mPreChunkSize;
+        }else{
+            track->mLengthTotal = 0;
+        }
+
+        track->mPreChunkSize = chunkSize;
+        info->mLengthTotal = track->mLengthTotal;
 
         if (info->mIsKey) {
             static const size_t kMaxNumSyncSamplesToScan = 20;
@@ -842,7 +1099,7 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
         }
 
         data += 16;
-        size -= 16;
+        n -= 16;
     }
 
     if (!mTracks.isEmpty()) {
@@ -868,7 +1125,8 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
     for (size_t i = 0; i < mTracks.size(); ++i) {
         Track *track = &mTracks.editItemAt(i);
 
-        if (track->mBytesPerSample > 0) {
+        if (Track::AUDIO==track->mKind){
+            if(track->mBytesPerSample > 0) {
             // Assume all chunks are roughly the same size for now.
 
             // Compute the avg. size of the first 128 chunks (if there are
@@ -881,7 +1139,7 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
 
             double avgChunkSize = 0;
             size_t j;
-            for (j = 0; j <= numSamplesToAverage; ++j) {
+            for (j = 0; j < numSamplesToAverage; ++j) {
                 off64_t offset;
                 size_t size;
                 bool isKey;
@@ -904,9 +1162,14 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
                 avgChunkSize += size;
             }
 
-            avgChunkSize /= numSamplesToAverage;
+            if (numSamplesToAverage > 1) {
+                avgChunkSize /= (numSamplesToAverage - 1);
+            }
 
             track->mAvgChunkSize = avgChunkSize;
+        }else{
+            continue;
+            }
         }
 
         int64_t durationUs;
@@ -918,6 +1181,7 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
         track->mMeta->setInt64(kKeyDuration, durationUs);
         track->mMeta->setInt32(kKeyMaxInputSize, track->mMaxSampleSize);
 
+        /*
         const char *tmp;
         CHECK(track->mMeta->findCString(kKeyMIMEType, &tmp));
 
@@ -945,6 +1209,7 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
                 return err;
             }
         }
+        */
     }
 
     mFoundIndex = true;
@@ -952,6 +1217,117 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
     return OK;
 }
 
+status_t AVIExtractor::parseIndx(off64_t offset, size_t size) {
+
+    if(size < 32) return ERROR_MALFORMED;
+
+    sp<ABuffer> buffer = new ABuffer(size);
+    ssize_t n = mDataSource->readAt(offset, buffer->data(), buffer->size());
+
+    if (n < (ssize_t)size) {
+        return n < 0 ? (status_t)n : ERROR_MALFORMED;
+    }
+
+    const uint8_t *data = buffer->data();
+    Track *track = &mTracks.editItemAt(mTracks.size() - 1); //directly after strh&strf
+    uint32_t sizePerIndexEntry   = U16LE_AT(&data[8]) * 4;
+    uint8_t indextype      = data[11];
+    uint32_t entriesInUse  = U32LE_AT(&data[12]);
+    off64_t  baseoffset    = U64LE_AT(&data[20]);
+
+    if(!sizePerIndexEntry) return ERROR_MALFORMED;
+
+    uint32_t maxEntries = (size - 32)/sizePerIndexEntry;
+    if(entriesInUse > maxEntries)
+    {
+        entriesInUse = maxEntries;
+    }
+
+#define AVI_INDEX_OF_INDEXES  0x00
+#define AVI_INDEX_OF_CHUNKS   0x01
+
+    mOffsetsAreAbsolute = true;
+    data += 32; //step into aIndex[]
+
+    if(indextype == AVI_INDEX_OF_CHUNKS)
+    {
+        double avgChunkSize = 0;
+
+        for(size_t i=0; i<entriesInUse; i++)
+        {
+            track->mSamples.push();
+            SampleInfo *info =
+                &track->mSamples.editItemAt(track->mSamples.size() - 1);
+            info->mOffset = (uint32_t)baseoffset + U32LE_AT(data) - 8;//need to point ##wb ##dc
+
+            size_t chunkSize = U32LE_AT(&data[4]);
+            info->mIsKey  = ((int32_t)chunkSize) > 0;//bit31 indicate keyframe
+
+            chunkSize = chunkSize & 0x7fffffff;
+            if (chunkSize > track->mMaxSampleSize)
+            {
+		ALOGE("parse Indx track->maxSize:%d, size:%d", track->mMaxSampleSize, chunkSize );
+                track->mMaxSampleSize = chunkSize;
+		track->mMeta->setInt32(kKeyMaxInputSize, track->mMaxSampleSize);
+            }
+
+            if(track->mSamples.size() > 1){
+                track->mLengthTotal += track->mPreChunkSize;
+            }else{
+                track->mLengthTotal = 0;
+            }
+
+            track->mPreChunkSize = chunkSize;
+            info->mLengthTotal = track->mLengthTotal;
+            if(track->mBytesPerSample > 0)
+            ALOGV("parseIndx, num=%d, chunkSize=%d, mLengthTotal=%d",i, chunkSize, info->mLengthTotal);
+
+            if (info->mIsKey) {
+                static const size_t kMaxNumSyncSamplesToScan = 20;
+
+                if (track->mNumSyncSamples < kMaxNumSyncSamplesToScan) {
+                    if (chunkSize > track->mThumbnailSampleSize) {
+                        track->mThumbnailSampleSize = chunkSize;
+
+                        track->mThumbnailSampleIndex =
+                        track->mSamples.size() - 1;
+                    }
+                }
+                ++track->mNumSyncSamples;
+            }
+
+            data += sizePerIndexEntry;
+            if (i == 0) {
+                track->mFirstChunkSize = size;
+                continue;
+            }
+            avgChunkSize += chunkSize;
+        }
+
+        if (entriesInUse > 1) {
+            avgChunkSize /= entriesInUse;
+        }
+        track->mAvgChunkSize = avgChunkSize;
+    }
+    else if(indextype == AVI_INDEX_OF_INDEXES)
+    {
+        for(size_t i=0; i<entriesInUse; i++)
+        {
+            off64_t stdIndexOffset = U64LE_AT(data);
+            uint32_t stdIndexSize  = U32LE_AT(&data[8]);
+            status_t err = parseIndx(stdIndexOffset, stdIndexSize);
+            if(err)
+            {
+                return err;
+            }
+            data += sizePerIndexEntry;
+        }
+    }
+
+    return OK;
+}
+
+
 static size_t GetSizeWidth(size_t x) {
     size_t n = 1;
     while (x > 127) {
@@ -962,11 +1338,47 @@ static size_t GetSizeWidth(size_t x) {
 }
 
 static uint8_t *EncodeSize(uint8_t *dst, size_t x) {
+
+#if 1
+    size_t  size_len = GetSizeWidth(x);
+    uint8_t  cnt_7bit_rightshift = 0;
+
+    ALOGI("EncodeSize,  x=0x%x, size_len=%d",
+        (uint32_t)x,  (uint32_t)size_len
+    );
+
+    // if use several bytes to save the length,  the bytes shold be in big endia mode.
+    // save the hightest 7bits in the first byte with bit7=1, which means the lower 7bits  are saved in the followed byte.
+    // save the higher 7bits in the followed byte with bit7=1.
+    // save the lowest 7bits in the lastest byte with bit7=0.
+    dst += size_len;
+    while(cnt_7bit_rightshift < size_len)
+    {
+        dst--;
+        // save the latest bytes firstly.
+        if( cnt_7bit_rightshift == 0 ) {
+            *dst = (x & 0x7f); }
+        else{
+            *dst = (x & 0x7f) | 0x80;
+        }
+
+        x >>= 7;
+        cnt_7bit_rightshift++;
+    }
+    dst += size_len;
+
+    ALOGI("EncodeSize,  x=0x%x,  [0,1]=0x%x,%x",
+        (uint32_t)x,  *(dst-2), *(dst-1)
+    );
+
+#else
     while (x > 127) {
         *dst++ = (x & 0x7f) | 0x80;
         x >>= 7;
     }
     *dst++ = x;
+#endif
+
     return dst;
 }
 
@@ -1007,11 +1419,24 @@ status_t AVIExtractor::addMPEG4CodecSpecificData(size_t trackIndex) {
     size_t size;
     bool isKey;
     int64_t timeUs;
-    status_t err =
-        getSampleInfo(trackIndex, 0, &offset, &size, &isKey, &timeUs);
 
-    if (err != OK) {
-        return err;
+    size_t sampleIndex = 0;
+    for (;;)
+    {
+        status_t err = getSampleInfo(trackIndex, sampleIndex, &offset, &size, &isKey, &timeUs);
+
+        if (err != OK) {
+            return err;
+        }
+
+        if (size <= 0)
+        {
+            sampleIndex ++;
+        }
+        else
+        {
+            break;
+        }
     }
 
     sp<ABuffer> buffer = new ABuffer(size);
@@ -1113,14 +1538,85 @@ status_t AVIExtractor::getSampleInfo(
         return -ERANGE;
     }
 
-    const Track &track = mTracks.itemAt(trackIndex);
+    Track *track = &mTracks.editItemAt(trackIndex);
+    uint32_t chunkType;
+    if (sampleIndex >= track->mSamples.size()) {
+        if(mIndexType == NO_INDEX)//parse movi data to get index info
+        {
+            while(sampleIndex >= track->mSamples.size()){
+                uint8_t tmp[12];
+                ssize_t n = mDataSource->readAt(track->mCurSamplePos, tmp, 8);
+                if (n < 8) {
+                    return (n < 0) ? n : (ssize_t)ERROR_MALFORMED;
+                }
+                chunkType = U32_AT(tmp);
 
-    if (sampleIndex >= track.mSamples.size()) {
-        return -ERANGE;
-    }
+                if(chunkType == FOURCC('L', 'I', 'S', 'T'))
+                {
+                    track->mCurSamplePos += 12; //skip LIST rec
+                    continue;
+                }
+
+                uint8_t hi = chunkType >> 24;
+                uint8_t lo = (chunkType >> 16) & 0xff;
+
+                if (hi < '0' || hi > '9' || lo < '0' || lo > '9') {
+                return ERROR_MALFORMED;
+                }
+
+                size_t tmpIndex = 10 * (hi - '0') + (lo - '0');
+
+                if (tmpIndex >= mTracks.size()) {
+                    return ERROR_MALFORMED;
+                }
+
+                uint32_t sampleSize = U32LE_AT(&tmp[4]);
+                if(trackIndex != tmpIndex)
+                {
+                    track->mCurSamplePos += (sampleSize + 8);
+                    if(track->mCurSamplePos & 1)//careful
+                    {
+                        ++track->mCurSamplePos;
+                    }
+                    continue;
+                }
+                //new sample
+                track->mSamples.push();
+                 if(track->mSamples.size() > 1){
+                    track->mLengthTotal += track->mPreChunkSize;
+                }else{
+                    track->mLengthTotal = 0;
+                }
+                track->mPreChunkSize = sampleSize;
+
+                SampleInfo *info =
+                    &track->mSamples.editItemAt(track->mSamples.size() - 1);
+                info->mOffset = track->mCurSamplePos;
+                info->mIsKey = true;//don't know.
+                info->mLengthTotal = track->mLengthTotal;
+
+                track->mCurSamplePos += (sampleSize + 8);
+                if(track->mCurSamplePos & 1)
+                {
+                    ++track->mCurSamplePos;
+                }
 
-    const SampleInfo &info = track.mSamples.itemAt(sampleIndex);
+                if(sampleIndex == 0)
+                {
+                    track->mFirstChunkSize = sampleSize;
+                    track->mAvgChunkSize = sampleSize; //don't care it
+                }
+            }
+            //TODO: actually don't need to execute the following data, should return now?
+        }
+        else
+        {
+            return -ERANGE;
 
+        }
+    }
+
+    const SampleInfo &info = track->mSamples.itemAt(sampleIndex);
     if (!mOffsetsAreAbsolute) {
         *offset = info.mOffset + mMovieOffset + 8;
     } else {
@@ -1136,9 +1632,9 @@ status_t AVIExtractor::getSampleInfo(
         return n < 0 ? (status_t)n : (status_t)ERROR_MALFORMED;
     }
 
-    uint32_t chunkType = U32_AT(tmp);
+    chunkType = U32_AT(tmp);
 
-    if (!IsCorrectChunkType(trackIndex, track.mKind, chunkType)) {
+    if (!IsCorrectChunkType(trackIndex, track->mKind, chunkType)) {
         return ERROR_MALFORMED;
     }
 
@@ -1147,19 +1643,24 @@ status_t AVIExtractor::getSampleInfo(
 
     *isKey = info.mIsKey;
 
-    if (track.mBytesPerSample > 0) {
+    if ( (Track::AUDIO==track->mKind)&&(track->mBytesPerSample > 0) ) {
+#if 0    
         size_t sampleStartInBytes;
         if (sampleIndex == 0) {
             sampleStartInBytes = 0;
         } else {
             sampleStartInBytes =
-                track.mFirstChunkSize + track.mAvgChunkSize * (sampleIndex - 1);
+                track->mFirstChunkSize + track->mAvgChunkSize * (sampleIndex - 1);
         }
 
-        sampleIndex = sampleStartInBytes / track.mBytesPerSample;
+        sampleIndex = sampleStartInBytes / track->mBytesPerSample;
+    }
+#else
+        sampleIndex = info.mLengthTotal / track->mBytesPerSample;
     }
+#endif
 
-    *sampleTimeUs = (sampleIndex * 1000000ll * track.mRate) / track.mScale;
+    *sampleTimeUs = (sampleIndex * 1000000ll * track->mRate) / track->mScale;
 
     return OK;
 }
@@ -1185,7 +1686,7 @@ status_t AVIExtractor::getSampleIndexAtTime(
 
     ssize_t closestSampleIndex;
 
-    if (track.mBytesPerSample > 0) {
+    if ((Track::AUDIO==track.mKind)&&(track.mBytesPerSample > 0)) {
         size_t closestByteOffset =
             (timeUs * track.mBytesPerSample)
                 / track.mRate * track.mScale / 1000000ll;
@@ -1193,9 +1694,25 @@ status_t AVIExtractor::getSampleIndexAtTime(
         if (closestByteOffset <= track.mFirstChunkSize) {
             closestSampleIndex = 0;
         } else {
-            closestSampleIndex =
-                (closestByteOffset - track.mFirstChunkSize)
-                    / track.mAvgChunkSize;
+            if(NO_INDEX != mIndexType && track.mSamples.size() > 0){
+                uint32_t i = 0;
+                const SampleInfo *info = &track.mSamples.itemAt(0);
+                while(info->mLengthTotal < closestByteOffset){
+                    ++i;
+                    if(i >= track.mSamples.size()){
+                        break;
+                    }
+                    info = &track.mSamples.itemAt(i);
+                    ALOGV("audiotrack seek, num=%d, mLengthTotal=%d",i, info->mLengthTotal);
+                }
+                closestSampleIndex = (info->mLengthTotal == closestByteOffset)? i: (i - 1);
+                ALOGI("mIndexType=%d, closestSampleIndex=%d, closestByteOffset=%d, info->mLengthTotal=%d, rate=%d, scale=%d, samplesize=%d",
+                    mIndexType,closestSampleIndex, closestByteOffset, info->mLengthTotal, track.mRate, track.mScale, track.mBytesPerSample);
+            }else{
+                closestSampleIndex =
+                    (closestByteOffset - track.mFirstChunkSize)
+                        / track.mAvgChunkSize;
+            }
         }
     } else {
         // Each chunk contains a single sample.
@@ -1203,6 +1720,10 @@ status_t AVIExtractor::getSampleIndexAtTime(
     }
 
     ssize_t numSamples = track.mSamples.size();
+    if(!numSamples)  //no sample index
+    {
+        return NOT_ENOUGH_DATA;
+    }
 
     if (closestSampleIndex < 0) {
         closestSampleIndex = 0;
@@ -1240,6 +1761,9 @@ status_t AVIExtractor::getSampleIndexAtTime(
         ++nextSyncSampleIndex;
     }
 
+    ALOGI("Track=%d, seek_mode=%d, sampleIndex=%d, closestSampleIndex=%d",
+                    track.mKind, mode, *sampleIndex, closestSampleIndex);
+
     switch (mode) {
         case MediaSource::ReadOptions::SEEK_PREVIOUS_SYNC:
         {
@@ -1254,11 +1778,16 @@ status_t AVIExtractor::getSampleIndexAtTime(
 
             return nextSyncSampleIndex < numSamples ? OK : UNKNOWN_ERROR;
         }
-
+#if 0
         case MediaSource::ReadOptions::SEEK_CLOSEST_SYNC:
         {
             if (prevSyncSampleIndex < 0 && nextSyncSampleIndex >= numSamples) {
-                return UNKNOWN_ERROR;
+                if (closestSampleIndex >= 0 && closestSampleIndex < numSamples) {
+                    *sampleIndex = closestSampleIndex; // seek to closestSampleIndex
+                    return OK;
+                } else {
+                    return UNKNOWN_ERROR;
+                }
             }
 
             if (prevSyncSampleIndex < 0) {
@@ -1277,9 +1806,76 @@ status_t AVIExtractor::getSampleIndexAtTime(
             *sampleIndex =
                 (dist1 < dist2) ? prevSyncSampleIndex : nextSyncSampleIndex;
 
+            ALOGI("sampleIndex=%d, prevSyncSampleIndex=%d, nextSyncSampleIndex=%d",
+                *sampleIndex, prevSyncSampleIndex, nextSyncSampleIndex);
+
             return OK;
         }
+#else
+        case MediaSource::ReadOptions::SEEK_CLOSEST_SYNC:
+        {
+            if (prevSyncSampleIndex < 0 && nextSyncSampleIndex >= numSamples) {
+                if (closestSampleIndex >= 0 && closestSampleIndex < numSamples) {
+                    *sampleIndex = closestSampleIndex; // seek to closestSampleIndex
+                    return OK;
+                } else {
+                    return UNKNOWN_ERROR;
+                }
+            }
+
+            if (prevSyncSampleIndex < 0) {
+                *sampleIndex = nextSyncSampleIndex;
+                return OK;
+            }
+
+            if (nextSyncSampleIndex >= numSamples) {
+                *sampleIndex = prevSyncSampleIndex;
+                return OK;
+            }
+
+            size_t dist1 = closestSampleIndex - prevSyncSampleIndex;
+            size_t dist2 = nextSyncSampleIndex - closestSampleIndex;
 
+            if(Track::VIDEO==track.mKind)
+            {
+                ALOGV("sampleIndex=%d, closestSampleIndex=%d",
+                    *sampleIndex, closestSampleIndex);
+                    
+                if(*sampleIndex < closestSampleIndex) //forward seek
+                {
+                    if(dist1 < dist2 && *sampleIndex  < prevSyncSampleIndex + 1)
+                    {
+                        *sampleIndex = prevSyncSampleIndex;
+                    }
+                    else
+                    {
+                        *sampleIndex = nextSyncSampleIndex;
+                    }
+                }
+                else //backward seek
+                {
+                    if(dist1 > dist2 && *sampleIndex  > nextSyncSampleIndex + 1)
+                    {
+                        *sampleIndex = nextSyncSampleIndex;
+                    }
+                    else
+                    {
+                        *sampleIndex = prevSyncSampleIndex;
+                    }
+                }
+            }
+            else
+            {
+                *sampleIndex =
+                    (dist1 < dist2) ? prevSyncSampleIndex : nextSyncSampleIndex;
+            }
+
+            ALOGI("sampleIndex=%d, prevSyncSampleIndex=%d, nextSyncSampleIndex=%d",
+                *sampleIndex, prevSyncSampleIndex, nextSyncSampleIndex);
+
+            return OK;
+        }
+#endif
         default:
             TRESPASS();
             break;
@@ -1300,7 +1896,7 @@ bool SniffAVI(
         // Just a tad over the mp3 extractor's confidence, since
         // these .avi files may contain .mp3 content that otherwise would
         // mistakenly lead to us identifying the entire file as a .mp3 file.
-        *confidence = 0.21;
+        *confidence = 0.31;
 
         return true;
     }
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 6a2a696..98de9af 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -57,6 +57,8 @@ LOCAL_SRC_FILES:=                         \
         avc_utils.cpp                     \
         mp4/FragmentedMP4Parser.cpp       \
         mp4/TrackFragment.cpp             \
+        FLVExtractor.cpp                  \
+        AVIExtractor.cpp                  \
 
 LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/include/media/stagefright/timedtext \
diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index fc6fd9c..dafc0d2 100644
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -32,8 +32,9 @@
 #include "include/OggExtractor.h"
 #include "include/WAVExtractor.h"
 #include "include/WVMExtractor.h"
-
+#include "include/FLVExtractor.h"
 #include "matroska/MatroskaExtractor.h"
+#include "include/AVIExtractor.h"
 
 #include <media/stagefright/foundation/AMessage.h>
 #include <media/stagefright/DataSource.h>
@@ -157,8 +158,10 @@ void DataSource::RegisterDefaultSniffers() {
     RegisterSniffer(SniffMPEG2TS);
     RegisterSniffer(SniffMP3);
     RegisterSniffer(SniffAAC);
+    RegisterSniffer(SniffAVI);
     RegisterSniffer(SniffMPEG2PS);
     RegisterSniffer(SniffWVM);
+    RegisterSniffer(SniffFLV);
 
     char value[PROPERTY_VALUE_MAX];
     if (property_get("drm.service.enabled", value, NULL)
diff --git a/media/libstagefright/FLVExtractor.cpp b/media/libstagefright/FLVExtractor.cpp
new file mode 100644
index 0000000..473f852
--- /dev/null
+++ b/media/libstagefright/FLVExtractor.cpp
@@ -0,0 +1,1048 @@
+/* *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License. */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "FLVExtractor"
+#include <utils/Log.h>
+
+#include "include/avc_utils.h"
+#include "include/FLVExtractor.h"
+
+#include <binder/ProcessState.h>
+#include <media/stagefright/foundation/hexdump.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/MediaBuffer.h>
+#include <media/stagefright/MediaBufferGroup.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/Utils.h>
+
+namespace android {
+
+struct FLVExtractor::FLVSource : public MediaSource {
+public:
+    FLVSource(const sp<FLVExtractor> &extractor, size_t trackIndex);
+
+    virtual status_t start(MetaData *params);
+    virtual status_t stop();
+
+    virtual sp<MetaData> getFormat();
+
+    virtual status_t read(
+            MediaBuffer **buffer, const ReadOptions *options);
+
+protected:
+    virtual ~FLVSource();
+
+private:
+    sp<FLVExtractor> mExtractor;
+    size_t mTrackIndex;
+    const FLVExtractor::Track &mTrack;
+    MediaBufferGroup *mBufferGroup;
+    size_t mTagIndex;
+
+    // for AVC.
+    bool mIsAVC;
+    size_t mNALLengthSize;
+    uint8_t *mSrcBuffer;
+
+    //for AAC.
+    bool mIsAAC;
+    
+    //sp<MP3Splitter> mSplitter;
+
+    size_t parseNALSize(const uint8_t *data) const;
+
+    DISALLOW_EVIL_CONSTRUCTORS(FLVSource);
+};
+
+FLVExtractor::FLVSource::FLVSource(
+        const sp<FLVExtractor> &extractor, size_t trackIndex)
+    : mExtractor(extractor),
+      mTrackIndex(trackIndex),
+      mTrack(mExtractor->mTracks.itemAt(trackIndex)),
+      mBufferGroup(NULL) {
+
+    const char *mime;
+    bool success = mTrack.mMeta->findCString(kKeyMIMEType, &mime);
+    CHECK(success);
+    mIsAVC = !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC);
+    mIsAAC = !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC);
+
+    if (mIsAVC) {
+        uint32_t type;
+        const void *data;
+        size_t size;
+        CHECK(mTrack.mMeta->findData(kKeyAVCC, &type, &data, &size));
+
+        const uint8_t *ptr = (const uint8_t *)data;
+
+        CHECK(size >= 7);
+        CHECK_EQ((unsigned)ptr[0], 1u);  // configurationVersion == 1
+
+        // The number of bytes used to encode the length of a NAL unit.
+        mNALLengthSize = 1 + (ptr[4] & 3);
+    }
+    ALOGE("mIsAVC=%d, mNALLengthSize=%d",mIsAVC,mNALLengthSize);
+
+}
+
+FLVExtractor::FLVSource::~FLVSource() {
+    if (mBufferGroup) {
+        stop();
+    }
+}
+
+status_t FLVExtractor::FLVSource::start(MetaData *params) {
+    CHECK(!mBufferGroup);
+
+    mBufferGroup = new MediaBufferGroup;
+
+    mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxTagSize));
+    mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxTagSize));
+    mTagIndex = 0;
+
+    mSrcBuffer = NULL;
+    if(mIsAVC)
+    {
+        mSrcBuffer =  new uint8_t[mTrack.mMaxTagSize]; ;
+    }
+
+    return OK;
+}
+
+status_t FLVExtractor::FLVSource::stop() {
+    CHECK(mBufferGroup);
+
+    delete mBufferGroup;
+    mBufferGroup = NULL;
+
+    if(NULL != mSrcBuffer)
+    {
+        delete[] mSrcBuffer;
+        mSrcBuffer = NULL;
+    }
+    return OK;
+}
+
+sp<MetaData> FLVExtractor::FLVSource::getFormat() {
+    return mTrack.mMeta;
+}
+
+size_t FLVExtractor::FLVSource::parseNALSize(const uint8_t *data) const {
+    switch (mNALLengthSize) {
+        case 1:
+            return *data;
+        case 2:
+            return U16_AT(data);
+        case 3:
+            return ((size_t)data[0] << 16) | U16_AT(&data[1]);
+        case 4:
+            return U32_AT(data);
+    }
+
+    // This cannot happen, mNALLengthSize springs to life by adding 1 to
+    // a 2-bit integer.
+    CHECK(!"Should not be here.");
+
+    return 0;
+}
+
+status_t FLVExtractor::FLVSource::read(
+        MediaBuffer **buffer, const ReadOptions *options) {
+     CHECK(mBufferGroup);
+
+    *buffer = NULL;
+
+    int64_t seekTimeUs;
+    ReadOptions::SeekMode seekMode;
+    if (options && options->getSeekTo(&seekTimeUs, &seekMode) && 0) {
+        //status_t err = mExtractor->getTagIndexAtTime(
+       //             mTrackIndex, seekTimeUs, seekMode, &mTagIndex);
+
+        //if (err != OK) {
+         //   return ERROR_END_OF_STREAM;
+        //}        
+    }
+
+    for (;;) {
+        off64_t offset;
+        size_t size;
+        bool isKey;
+        int64_t timeUs;
+        status_t err = mExtractor->getTagInfo(mTrackIndex, mTagIndex, &offset, &size, &isKey, &timeUs);
+
+        ++mTagIndex;
+
+        //ALOGE("getTagInfo offset:%4lld, size:%d, trackID:%d,  tagId:%d,time:%4lld", offset, size,mTrackIndex, mTagIndex, timeUs);
+        if (err != OK) {
+           // if( mTagIndex < mTrack.mTags.size() ) {
+            //    continue;
+            //} else {
+                return ERROR_END_OF_STREAM;
+            //}
+        }
+        if(size > mTrack.mMaxTagSize)
+        {
+            ALOGE("buffer is not enough, size=%d,maxsize=%d",size, mTrack.mMaxTagSize);
+            return ERROR_MALFORMED;
+        }
+
+        MediaBuffer *out;
+        CHECK_EQ(mBufferGroup->acquire_buffer(&out), (status_t)OK);
+        //
+        out->meta_data()->setInt64(kKeyTime, timeUs);
+        if (isKey) {
+            out->meta_data()->setInt32(kKeyIsSyncFrame, 1);
+        }
+
+        if(!mIsAVC)
+        {
+            ssize_t n = mExtractor->mDataSource->readAt(offset, out->data(), size);
+            if (n < (ssize_t)size) {
+                out->release();
+                return n < 0 ? (status_t)n : (status_t)ERROR_MALFORMED;
+            }
+
+            if(!mIsAAC)
+            {
+                out->set_range(0, size);
+            }
+            else
+            {
+                // read out one AACAUDIODATA(the 1Byte head of AUDIODATA has been skipped).
+                /*   struct for AACAUDIODATA
+                AACPacketType       UI8         0: AAC sequence header
+                                                1: AAC raw
+                Data                UI8[n]      if AACPacketType == 0
+                                                    AudioSpecificConfig
+                                                else if AACPacketType == 1
+                                                    Raw AAC frame data
+                */
+                 // NOTE: skip the  the header of AACAUDIODATA(1Bytes).
+                out->set_range(1, (size>1)?(size-1):0);
+            }
+            
+            *buffer = out;
+        }
+        else
+        {
+            // Whole NAL units are returned but each fragment is prefixed by
+            // the start code (0x00 00 00 01).
+            uint8_t *dstData;
+            uint8_t *srcData;
+            size_t srcOffset;
+            size_t dstOffset;
+
+            /* Read one AVCVIdeoPacket  to the temp buffer( the 1Byte header of VIDEODATA has 
+                 been skipped ).  */
+            ssize_t n = mExtractor->mDataSource->readAt(offset, mSrcBuffer, size);
+            if ((n < (ssize_t)size ) || (size < 4)) {
+                out->release();
+                return n < 0 ? (status_t)n : (status_t)ERROR_MALFORMED;
+            }
+
+            // check the AVCPacketType.  Only  send out AVC NALU.
+            if( mSrcBuffer[0] != 1)
+            {
+                // AVCPacketType has been saved in meta data. discard it.
+                ALOGE("AVCPacketType = %d, discard. ",mSrcBuffer[0]);
+                out->release();
+                continue;
+            }
+            // skip the header of AVCVIdeoPacket(4Bytes).
+            size  -= 4;
+            srcData = mSrcBuffer + 4;
+            srcOffset = 0;
+            dstData = (uint8_t *)out->data();
+            dstOffset = 0;
+
+            while (srcOffset < size) {
+                bool isMalFormed = (srcOffset + mNALLengthSize > size);
+                size_t nalLength = 0;
+                if (!isMalFormed) {
+                    nalLength = parseNALSize(&srcData[srcOffset]);
+                    srcOffset += mNALLengthSize;
+                    isMalFormed = srcOffset + nalLength > size;
+                }
+
+                if (isMalFormed) {
+                    ALOGE("Video is malformed,srcOffset=%d, nalLength=%d, size=%d",srcOffset,nalLength,size);
+                    out->release();
+                    return ERROR_MALFORMED;
+                }
+
+                if (nalLength == 0) {
+                    ALOGE("nalLength is error or end of the tag");
+                    break;
+                }
+
+                CHECK(dstOffset + 4 <= out->size());
+
+                dstData[dstOffset++] = 0;
+                dstData[dstOffset++] = 0;
+                dstData[dstOffset++] = 0;
+                dstData[dstOffset++] = 1;
+                memcpy(&dstData[dstOffset], &srcData[srcOffset], nalLength);
+                srcOffset += nalLength;
+                dstOffset += nalLength;
+            }
+            CHECK_EQ(srcOffset, size);
+            CHECK(out != NULL);
+            out->set_range(0, dstOffset);
+
+             *buffer = out;
+        }
+       break;
+    }
+
+    return OK;
+}
+
+FLVExtractor::FLVExtractor(const sp<DataSource> &dataSource)
+    : mDataSource(dataSource) {
+    mInitCheck = parseHeaders();
+
+    if (mInitCheck != OK) {
+        mTracks.clear();
+    }
+}
+
+FLVExtractor::~FLVExtractor(){
+}
+
+size_t FLVExtractor::countTracks() {
+    return mTracks.size();
+}
+
+sp<MediaSource> FLVExtractor::getTrack(size_t index) {
+    return index < mTracks.size() ? new FLVSource(this, index) : NULL;
+}
+
+sp<MetaData> FLVExtractor::getTrackMetaData(
+        size_t index, uint32_t flags) {
+    return index < mTracks.size() ? mTracks.editItemAt(index).mMeta : NULL;
+}
+
+sp<MetaData> FLVExtractor::getMetaData() {
+    sp<MetaData> meta = new MetaData;
+
+    if (1){//mInitCheck == OK) {
+        meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_CONTAINER_FLV);
+    }
+
+    return meta;
+}
+
+uint32_t FLVExtractor::flags() const {
+    if(1) //don't support seek 
+    {
+        return CAN_PAUSE;
+    }
+    else
+    {
+        //return MediaExtractor::flags();
+    }
+}
+
+status_t FLVExtractor::parseHeaders() {
+    mTracks.clear();
+    
+    off64_t dataSize = 0;
+    status_t err = mDataSource->getSize(&dataSize);
+    if(err == ERROR_UNSUPPORTED)
+    {
+        dataSize = -1;
+    }
+    else if(err != OK)
+    {
+        return err;
+    }
+    
+    ssize_t res = parseTagHeaders(0ll, dataSize);
+
+    if (res < 0) {
+        return (status_t)res;
+    }
+
+    return OK;
+}
+
+status_t FLVExtractor::parseTagHeaders(off64_t offset, off64_t size) {
+    sp<MetaData> meta = new MetaData;
+    const char *mime = NULL;
+    int32_t maxTagSize = 0;
+    
+    if (size >= 0 && size < 9) {
+        return ERROR_MALFORMED;
+    }
+
+    uint8_t hdr[9];
+    if (mDataSource->readAt(offset, hdr, 9) < 9) {
+        return ERROR_IO;
+    }
+    //ALOGE("parseTagHeaders hdr:0x%x%x%x%x%x%x%x%x%x", hdr[0],hdr[1],hdr[2],hdr[3],hdr[4],hdr[5],hdr[6],hdr[7],hdr[8] );
+
+    if(hdr[4]&0x4) {//Audio tags are present
+        ALOGE(" detect audio tags");
+        mTracks.push();
+        Track *track = &mTracks.editItemAt( mTracks.size() - 1 );
+        maxTagSize = FLV_AUDIO_TAG_MAX_SIZE;
+        sp<MetaData> meta = new MetaData;
+        meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG);
+        track->mKind = Track::AUDIO;
+        track->mMeta = meta;
+        track->mMaxTagSize = maxTagSize;
+     }
+
+    if(hdr[4]&0x1) {//Video tags are present
+        ALOGE(" detect video tags");
+        mTracks.push();
+        Track *track = &mTracks.editItemAt( mTracks.size() - 1 );
+        maxTagSize = FLV_VIDEO_TAG_MAX_SIZE;
+        sp<MetaData> meta = new MetaData;
+        meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_H263);
+        track->mKind = Track::VIDEO;
+        track->mMeta = meta;
+        track->mMaxTagSize = maxTagSize;
+    }
+    
+    uint32_t DataOffset = U32_AT(&hdr[5]);
+    
+    ssize_t res = parseTag(offset+DataOffset, size);
+
+    if (res < 0) {
+        return (status_t)res;
+    }
+
+    return OK;
+}
+
+status_t FLVExtractor::parseTag(off_t offset, off64_t size, int depth) {
+     if (size >= 0 && size < (4 + SIZE_OF_TAG_HEAD + 1) ) {
+        return ERROR_MALFORMED;
+    }
+    uint8_t tmp[4 + SIZE_OF_TAG_HEAD + 1];
+
+    ssize_t n = mDataSource->readAt(offset, tmp, 4 + SIZE_OF_TAG_HEAD + 1);
+
+    if (n < (4 + SIZE_OF_TAG_HEAD + 1)) {
+        ALOGE("readSize:%d", n );
+        return (n < 0) ? n : (ssize_t)ERROR_MALFORMED;
+    }
+
+    uint32_t type, len, flags;
+    uint32_t *p_pts;
+    const char *mime = NULL;
+    Track *Vtrack = NULL, *Atrack=NULL;
+    //ALOGE("parseTagHeaders hdr:0x%x%x%x%x%x%x%x%x%x", tmp[4],tmp[5],tmp[6],tmp[7],tmp[8],tmp[9],tmp[10],tmp[11],tmp[15]);
+    type    = tmp[4];
+    len    = (tmp[5] << 16) | (tmp[6] << 8) | (tmp[7]);
+    //*p_pts  = (tmp[8] << 16) | (tmp[9] << 8) | (tmp[10]);
+    flags   = tmp[4 + SIZE_OF_TAG_HEAD];
+
+    //ALOGE("parseTag type:0x%x, len:0x%x, flags:0x%x", type, len, flags);
+    
+    for( uint32_t i=0; i<mTracks.size(); i++) {
+        Track *track = &mTracks.editItemAt( i );
+        track->mCurTagPos = offset + 4 + SIZE_OF_TAG_HEAD + len;
+
+        if( track->mKind == Track::VIDEO )
+            Vtrack = track;
+        else if ( track->mKind == Track::AUDIO)
+            Atrack = track;
+        else
+            ALOGE("parseTag error, track is invalid");
+    }
+
+    if( FLV_TAG_TYPE_META == type) {
+        flv_read_metabody(offset+4+SIZE_OF_TAG_HEAD);
+    }
+
+    if( Vtrack) {
+        offset = Vtrack->mCurTagPos;
+        for(;;) {            
+            ssize_t n = mDataSource->readAt(offset, tmp, 4 + SIZE_OF_TAG_HEAD + 1);
+
+            if (n < (4 + SIZE_OF_TAG_HEAD + 1)) {
+                ALOGE("readSize:%d", n );
+                return (n < 0) ? n : (ssize_t)ERROR_MALFORMED;
+            }
+            
+            //ALOGE("parseVideoTagHeaders hdr:0x%x,%x,%x,%x,%x,%x,%x,%x,%x", tmp[4],tmp[5],tmp[6],tmp[7],tmp[8],tmp[9],tmp[10],tmp[11],tmp[15]);
+            type    = tmp[4];
+            len    = (tmp[5] << 16) | (tmp[6] << 8) | (tmp[7]);
+            flags   = tmp[4 + SIZE_OF_TAG_HEAD];
+
+            if(FLV_TAG_TYPE_VIDEO==type) {
+                Vtrack->mCurTagPos = offset;
+                ALOGE("get video tag Header!");
+                switch(flags&0x0f)
+                {
+                case FLV_CODECID_H263:
+                    Vtrack->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_H263);
+                    break;
+                case FLV_CODECID_AVC:
+                    Vtrack->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_AVC);
+                    // NOTE: skip the head of VIDEODATA(1Byte) and the header of AVCPacketType(4Bytes).
+                    if( len > 5 ) // 1+4
+                    {
+                        /*   struct for AVCVIDEOPACKET
+                            AVCPacketType       UI8         0: AVC sequence header
+                                                            1: AVC NALU
+                                                            2: AVC end of sequence (lower level NALU
+                                                                sequence ender is not required or supported)
+                            CompositionTime     SI24        if AVCPacketType == 1
+                                                                Composition time offset
+                                                            else
+                                                                0
+                            Data                            UI8[n]      if AVCPacketType == 0
+                                                                AVCDecoderConfigurationRecord
+                                                            else if AVCPacketType == 1
+                                                                One or more NALUs (can be individual
+                                                                slices per FLV packets; that is, full frames
+                                                                are not strictly required)
+                                                            else if AVCPacketType == 2
+                                                                Empty
+                        */
+                        uint8_t *pSrcBuffer;
+                        ssize_t n;
+                        
+                        pSrcBuffer = new uint8_t[len-1];
+                        if(NULL ==  pSrcBuffer)
+                        {
+                            return MEDIA_ERROR_BASE;
+                        }
+
+                        // read one AVCVIdeoPacket. skip the head of VIDEODATA(1Byte).
+                        n = mDataSource->readAt(offset + 4 + SIZE_OF_TAG_HEAD + 1, pSrcBuffer, len-1);
+                        if (n < len-1) {
+                            ALOGE("read AVCVIdeoPacket error, size:%d vs %d",size,  n );
+                            delete[] pSrcBuffer;
+                            return ERROR_MALFORMED;
+                        }
+
+                        // check the AVCPacketType.
+                        if(pSrcBuffer[0] == 0)
+                        {
+                            // save the AVCDecoderConfigurationRecord in meta data.
+                            // skip the head of AVCVIdeoPacket(4Bytes).
+                            Vtrack->mMeta->setData(kKeyAVCC, kTypeAVCC, &(pSrcBuffer[4]), len-5);
+                        }
+                        // TODO: else.
+
+                        delete[] pSrcBuffer;
+                    }
+                    break;
+                case FLV_CODECID_SCREEN:
+                case FLV_CODECID_SCREEN2:
+                case FLV_CODECID_VP6:
+                case FLV_CODECID_VP6A:
+                default:
+                    break;
+                }
+                break;
+            } else {
+                offset += 4 + SIZE_OF_TAG_HEAD + len;
+                continue;
+            }
+        }
+    }
+
+   if(Atrack) {
+        offset = Atrack->mCurTagPos;
+        for(;;) {            
+            ssize_t n = mDataSource->readAt(offset, tmp, 4 + SIZE_OF_TAG_HEAD + 1);
+
+            if (n < (4 + SIZE_OF_TAG_HEAD + 1)) {
+                ALOGE("readSize:%d", n );
+                return (n < 0) ? n : (ssize_t)ERROR_MALFORMED;
+            }
+            
+            //ALOGE("parseAudioTagHeaders hdr:0x%x,%x,%x,%x,%x,%x,%x,%x,%x", tmp[4],tmp[5],tmp[6],tmp[7],tmp[8],tmp[9],tmp[10],tmp[11],tmp[15]);
+            type    = tmp[4];
+            len    = (tmp[5] << 16) | (tmp[6] << 8) | (tmp[7]);
+            flags   = tmp[4 + SIZE_OF_TAG_HEAD];
+
+            if(FLV_TAG_TYPE_AUDIO==type) {
+                ALOGE("get audio tag Header!");
+                Atrack->mCurTagPos = offset;
+                uint8_t audio_codec = flags&FLV_AUDIO_CODECID_MASK;
+                switch(audio_codec)
+                {
+                    case FLV_CODECID_MP3:
+                        Atrack->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG);
+                        break;
+                    case FLV_CODECID_AAC:
+                        Atrack->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AAC);
+                        break;
+                    case FLV_CODECID_NELLYMOSER_8HZ_MONO:                            
+                    case FLV_CODECID_NELLYMOSER:                            
+                    case FLV_CODECID_PCM_BE:
+                    case FLV_CODECID_ADPCM:
+                    case FLV_CODECID_PCM_LE:                            
+                    default:
+                        const char *mime = "application/octet-stream";
+                        Atrack->mMeta->setCString(kKeyMIMEType, mime);
+                        break;
+                }
+
+                //--sample rate.(Hz).bit[3:2].
+                if( audio_codec != FLV_CODECID_NELLYMOSER_8HZ_MONO)
+                {
+                    switch( flags & FLV_AUDIO_RATE_MASK )
+                    {
+                        case FLV_AUDIO_RATE_5500:
+                            Atrack->mMeta->setInt32(kKeySampleRate, 5500);
+                            break;
+                        case FLV_AUDIO_RATE_11000:
+                            Atrack->mMeta->setInt32(kKeySampleRate, 11025);
+                            break;
+                        case FLV_AUDIO_RATE_22000:
+                            Atrack->mMeta->setInt32(kKeySampleRate, 22050);
+                            break;
+                        case FLV_AUDIO_RATE_44000:
+                            Atrack->mMeta->setInt32(kKeySampleRate, 44100);
+                            break;
+                        default:
+                            break;
+                    }
+                }
+                
+                //--sample size(8/16 bits/sample),bit[1]
+                if( flags & FLV_AUDIO_SIZE_MASK )
+                {
+                   //bitspersample = 16;
+                }
+                else
+                {
+                    //bitspersample = 8;
+                }
+
+                //--sample channnel(mono/stereo),bit[0]
+                if( flags & FLV_AUDIO_CHANNEL_MASK )
+                {
+                    Atrack->mMeta->setInt32(kKeyChannelCount, 2);
+                }
+                else
+                {
+                    Atrack->mMeta->setInt32(kKeyChannelCount, 1);
+                }
+
+                break;
+            } else {
+                offset += 4 + SIZE_OF_TAG_HEAD + len;
+                continue;
+            }
+        }
+    }
+
+    return OK;
+}
+
+ssize_t FLVExtractor::flv_read_metabody(off_t offset)
+{
+    int32_t keylen;
+    uint8_t buffer[11]; //only needs to hold the string "onMetaData". Anything longer is something we don't want.
+
+    //first object needs to be "onMetaData" string
+    if(mDataSource->readAt(offset, buffer, 4) <1)
+        return ERROR_IO;
+
+    CHECK (buffer[0] == AMF_DATA_TYPE_STRING );
+    if (amf_get_string(offset+1, buffer, sizeof(buffer)) <= 11) {
+ 	   return ERROR_MALFORMED;
+    }
+    CHECK (!strcmp((const char *)buffer, "onMetaData"));
+
+    offset += (1+12);
+    //parse the second object (we want a mixed array)
+    //ALOGE("flv_read_metabody, offset:%d", offset);
+    return amf_parse_object((const char *)buffer, offset, 0);        
+}
+ssize_t FLVExtractor::amf_get_string(uint32_t offset, uint8_t *buffer, int32_t buffsize)
+{
+   int length;
+   mDataSource->readAt(offset, buffer, 2);
+   length =U16_AT(buffer);
+   //ALOGE("amf_get_string keylen:%d", length);
+    if (length >= buffsize) {
+        return -1;
+    }
+
+    mDataSource->readAt(offset+2, buffer, length);
+    buffer[length] = '\0';
+    //ALOGE("amf_get_string %s", buffer);
+    return length+2;
+}
+
+static double av_int2dbl(int64_t v)
+{
+    //if(v+v > 0xFFEULL<<52)
+//      return 0.0/0.0;
+//      return ldexp( (double)(  ( (v&((1LL<<52)-1))  +  (1LL<<52)  )  *  (v>>63|1)  ),(int)((v>>52&0x7FF)-1075) );
+
+    off64_t tmp;
+    off64_t k_tmp;
+    double x; 
+    int exp_p;
+    int i =0;
+
+    //--(fract<<52).
+    k_tmp = 1;
+    k_tmp = (k_tmp<<52) -1;
+    tmp = v & k_tmp;
+
+    //--add signal and 1.fract.
+    k_tmp = 1;
+    k_tmp = (k_tmp<<52);
+    tmp += k_tmp;	//(1+fract)<<52.
+    k_tmp = (v>>63) | 1 ; //-- x*(-1)^signal.
+    tmp = tmp * k_tmp;
+
+    //--exponent.
+    exp_p = (int)( (v>>52&0x7FF) - 52 - 1023 );
+    if(exp_p>=0)
+    {
+        tmp = ( tmp << exp_p);
+    }
+    else
+    {
+        exp_p = -exp_p;
+
+        //tmp = (tmp >> exp_p);
+        for(i=0;i < exp_p;i++)
+        {
+            tmp = tmp>>1;
+        }
+    }
+
+    x= (double)tmp;
+    return x;
+}
+
+ssize_t FLVExtractor::amf_parse_object(const char *key, uint32_t offset, int depth)
+{
+    int i_track;
+
+    AMFDataType amf_type;
+    uint8_t str_val[256], tmp[8];
+    double num_val = 0;
+    uint32_t len = 0;
+    uint32_t array_num;
+
+    if(mDataSource->readAt(offset, tmp, 4)<1)
+        return ERROR_IO;
+
+    //ALOGE("amf_parse_object,offset:%d, tmp:%x, %x, %x, %x", offset, tmp[0],tmp[1],tmp[2],tmp[3]);
+    amf_type = (AMFDataType)tmp[0];
+
+    offset += 1;
+    //ALOGE("amf_parse_object, amf-type:0x%x", amf_type);
+    switch(amf_type) {
+        case AMF_DATA_TYPE_NUMBER:
+            mDataSource->readAt(offset, tmp, 8);
+            //ALOGE("amf_parse_object,tmp:%x, %x, %x, %x,%x, %x, %x, %x", tmp[0],tmp[1],tmp[2],tmp[3],tmp[4],tmp[5],tmp[6],tmp[7]);
+            offset += 8;
+            num_val = av_int2dbl(U64_AT(tmp));
+            //ALOGE("AMF_DATA_TYPE_NUMBER, %4llf", num_val);
+            break;
+        case AMF_DATA_TYPE_BOOL:
+            mDataSource->readAt(offset, &num_val, 1);
+            offset+=1;
+            break;
+        case AMF_DATA_TYPE_STRING:
+	    {
+		int i = amf_get_string(offset, str_val, sizeof(str_val));
+		if(i < 0)
+			return -1;
+		len = i;
+                offset += len;
+	    }
+            break;
+        case AMF_DATA_TYPE_OBJECT: 
+    /*        while((uint32_t)stream_Tell(p_stream) < max_pos - 2 && amf_get_string(str_val, sizeof(str_val)) > 0) {
+                if(amf_parse_object(str_val, max_pos, depth + 1) < 0)
+                    return -1; //if we couldn't skip, bomb out.
+            }
+            if(get_byte(p_stream) != AMF_END_OF_OBJECT)
+                return -1;
+   */
+            break;
+        case AMF_DATA_TYPE_NULL:
+        case AMF_DATA_TYPE_UNDEFINED:
+        case AMF_DATA_TYPE_UNSUPPORTED:
+            break; //these take up no additional space
+        case AMF_DATA_TYPE_MIXEDARRAY:
+            mDataSource->readAt(offset, tmp, 4);
+            offset += 4;
+
+            array_num = U32_AT(tmp);
+            //ALOGE("AMF_DATA_TYPE_MIXEDARRAY, array_num:%d",array_num );
+            
+           for(uint32_t i=0; i<array_num; i++) {
+                len = amf_get_string(offset, str_val, sizeof(str_val));
+                offset += len;
+                offset = amf_parse_object((const char*)str_val, offset, depth + 1);
+            }
+
+            mDataSource->readAt(offset, &str_val, 3);
+            offset +=3;
+            if((str_val[0]|str_val[1]|str_val[2] )!= AMF_END_OF_OBJECT)
+                return -1;
+
+            return offset;
+            break;
+        case AMF_DATA_TYPE_ARRAY: 
+        /*    unsigned int arraylen, i;
+
+            arraylen = get_be32(p_stream);//--length of the array.
+
+            if (depth == 2 && key)
+            {
+                uint32_t array_elem_size = 0;
+            
+                //--arraylen of two tables must be equal.
+                if(!strcmp(key,"filepositions"))
+                {
+                    p_sys->haskeyframe = 1;
+                    p_sys->key_table_pos = stream_Tell(p_stream);
+                    p_sys->key_table_len = arraylen;
+                    array_elem_size = 9;//-9B per element.
+                }
+                else if(!strcmp(key,"times"))
+                {
+                    p_sys->key_table_tim = stream_Tell(p_stream);
+                    array_elem_size = 9;
+                }
+
+                if (array_elem_size > 0)
+                {
+                    mplayer_SetSeekable(SCI_TRUE);
+                }
+
+                if(array_elem_size > 0 )
+                {
+                    uint32_t cur_pos = stream_Tell(p_stream);
+                    uint32_t next_pos;
+
+                    next_pos = cur_pos + arraylen*array_elem_size;
+                    if(next_pos >= max_pos)
+                    {
+                        return -1;
+                    }
+                    else
+                    {
+                        FILE_SEEK(p_stream,next_pos,SEEK_SET);
+                        break;
+                    }
+                }
+            }
+
+            for(i = 0; i < arraylen && (uint32_t)stream_Tell(p_stream) < max_pos - 1; i++) {
+                if(amf_parse_object(NULL, max_pos, depth + 1) < 0)
+                    return -1; //if we couldn't skip, bomb out.
+            }*/
+            break;
+        case AMF_DATA_TYPE_DATE:
+            offset+=(8+2);
+            break;
+        default: //unsupported type, we couldn't skip
+            return -1;
+    }
+
+    if (depth == 1 && key)
+    {
+        Track *track, *vtrack=NULL, *atrack=NULL;
+        for( uint32_t i=0; i<mTracks.size(); i++) {
+            Track *track = &mTracks.editItemAt( i );
+            if( track->mKind == Track::VIDEO )
+                vtrack = track;
+            else if ( track->mKind == Track::AUDIO)
+                atrack = track;
+            else
+                ALOGE("parseTag error, track is invalid");
+        }
+
+        //ALOGE("amf_parse_object, key:%s", key);
+        //only look for metadata values when we are not nested and key != NULL
+        if(amf_type == AMF_DATA_TYPE_BOOL) {
+            if(!strcmp(key,"hasAudio"))
+            {
+                
+            }
+            else if(!strcmp(key, "stereo"))
+            {
+                if(atrack ) atrack->mMeta->setInt32(kKeyChannelCount, 2);
+            }
+            else if(!strcmp(key,"hasVideo"))
+            {
+                
+            }
+            else if(!strcmp(key,"hasKeyframes"))
+            {
+                
+            }
+            else if(!strcmp(key,"canSeekToEnd"))
+            {
+                
+            }
+        } else if(amf_type== AMF_DATA_TYPE_NUMBER) {
+            if(!strcmp(key, "duration"))
+            {
+                ALOGE("amf_parse_object, duration:%.2fs", num_val);
+                if(vtrack) {
+                    vtrack->mMeta->setInt64(kKeyDuration, (num_val)*FLV_MOVIE_TIMESCALE);
+                    vtrack->mMeta->setInt32(kKeyMaxInputSize, vtrack->mMaxTagSize);
+                }
+
+                if(atrack) {                
+                    atrack->mMeta->setInt64(kKeyDuration, (num_val)*FLV_MOVIE_TIMESCALE);
+                    atrack->mMeta->setInt32(kKeyMaxInputSize, atrack->mMaxTagSize);
+                }
+            }
+            else if(!strcmp(key, "videocodecid"))
+            {
+                
+            }
+            else if(!strcmp(key, "width") && num_val > 0)
+            {
+               ALOGE("amf_parse_object, width:%4llf", num_val);
+               if(vtrack )
+                   vtrack->mMeta->setInt32(kKeyWidth, num_val);        
+            }
+            else if(!strcmp(key, "height") && num_val > 0)
+            {
+                ALOGE("amf_parse_object, height:%4llf", num_val);
+                if(vtrack ) vtrack->mMeta->setInt32(kKeyHeight, num_val);
+            }
+            else if(!strcmp(key,"lastkeyframetimestamp"))
+            {
+                
+            }
+            else if(!strcmp(key,"framerate")&& num_val > 0)
+            {
+                
+            }
+            else if(!strcmp(key, "audiocodecid"))
+            {
+                //flv_set_audio_codec((int)num_val << FLV_AUDIO_CODECID_OFFSET);
+            }
+            else if(!strcmp(key,"audiosamplerate")&& num_val > 0)
+            {
+                ALOGE("amf_parse_object, audiosamplerate:%4llf", num_val);
+               if(atrack) atrack->mMeta->setInt32(kKeySampleRate, num_val);
+            }
+            else if(!strcmp(key,"audiosamplesize")&& num_val >= 0)
+            {
+                
+            }
+        }//--end of "else if(amf_type == AMF_DATA_TYPE_NUMBER)"
+    }
+
+    return offset;
+}
+
+status_t FLVExtractor::getTagInfo(
+        size_t trackIndex, size_t tagIndex,
+        off64_t *offset, size_t *size, bool *isKey,
+        int64_t *tagTimeUs) {
+    if (trackIndex >= mTracks.size()) {
+        ALOGE("trackId:%d, size:%d", trackIndex, mTracks.size());
+        return -ERANGE;
+    }
+    uint32_t tagType;
+    Track *track = &mTracks.editItemAt(trackIndex);
+    //ALOGE("getTagInfo trackID:%d, tagId:%d, tagNum:%d",trackIndex, tagIndex, track->mTags.size());
+    while(tagIndex >= track->mTags.size()) {
+            uint8_t tmp[4+SIZE_OF_TAG_HEAD+1];
+            ssize_t n = mDataSource->readAt(track->mCurTagPos, tmp, 4+SIZE_OF_TAG_HEAD+1);
+            //ALOGE("getTagInfo pos:%x, tmp:%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x", track->mCurTagPos,
+            //    tmp[0],tmp[1],tmp[2],tmp[3],tmp[4],tmp[5],tmp[6],tmp[7],tmp[8],tmp[9],tmp[10],tmp[11],tmp[12],tmp[13],tmp[14],tmp[15]);
+            if (n < (4+SIZE_OF_TAG_HEAD+1)) {
+                return (n < 0) ? n : (ssize_t)ERROR_MALFORMED;
+            }
+
+            tagType = tmp[4]&0x1F;
+            uint32_t tagSize = (tmp[5] << 16) | (tmp[6] << 8) | (tmp[7]);
+            if( ((FLV_TAG_TYPE_AUDIO== tagType)&&(track->mKind != Track::AUDIO)) || ((FLV_TAG_TYPE_VIDEO== tagType)&&(track->mKind != Track::VIDEO)) ) {
+                track->mCurTagPos += (tagSize + 4 + SIZE_OF_TAG_HEAD);                
+                continue;
+            }
+            //new tag
+            track->mTags.push();
+            TagInfo *info = &track->mTags.editItemAt(track->mTags.size() - 1);
+            info->mOffset = track->mCurTagPos;
+            info->mIsKey = true;//don't know.
+            
+            //ALOGE("getTagInfo push pos:%x, info:%x ", track->mCurTagPos, info->mOffset);
+
+            track->mCurTagPos += (tagSize + 4+SIZE_OF_TAG_HEAD);
+            
+            if(tagIndex == 0)
+            {
+                track->mFirstTagSize = tagSize;
+                track->mAvgTagSize = tagSize; //don't care it
+            }
+    //TODO: actually don't need to execute the following data, should return now?
+    }
+
+    const TagInfo &info = track->mTags.itemAt(tagIndex);
+    *offset = info.mOffset;
+
+    *size = 0;
+
+    uint8_t tmp[4+SIZE_OF_TAG_HEAD+1];
+    ssize_t n = mDataSource->readAt(info.mOffset, tmp, 4+SIZE_OF_TAG_HEAD+1);
+    
+    //ALOGE("getTagInfo pos:%x, tmp:%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x", info.mOffset,
+    //    tmp[0],tmp[1],tmp[2],tmp[3],tmp[4],tmp[5],tmp[6],tmp[7],tmp[8],tmp[9],tmp[10],tmp[11],tmp[12],tmp[13],tmp[14],tmp[15]);
+
+    if (n < (4+SIZE_OF_TAG_HEAD+1) ) {
+        return n < 0 ? (status_t)n : (status_t)ERROR_MALFORMED;
+    }
+
+    *offset = info.mOffset+4+SIZE_OF_TAG_HEAD+1;
+    *size = (tmp[5] << 16) | (tmp[6] << 8) | (tmp[7]);
+    *size -= 1;
+    *isKey = info.mIsKey;
+    *tagTimeUs = ( (tmp[8] << 16) | (tmp[9] << 8) | (tmp[10]) )*1000;
+    
+    //ALOGE("getTagInfo timeUs:%4lld", *tagTimeUs);
+
+    return OK;
+}
+
+bool SniffFLV(
+        const sp<DataSource> &source, String8 *mimeType, float *confidence,
+        sp<AMessage> *) {
+    char tmp[4];
+    if (source->readAt(0, tmp, 4) < 4) {
+        return false;
+    }
+
+    if ( !memcmp(tmp, "FLV", 3)) {
+         ALOGE("detect FLV files!!!!");
+        mimeType->setTo(MEDIA_MIMETYPE_CONTAINER_FLV);
+
+        // Just a tad over the mp3 extractor's confidence, since
+        // these FLV files may contain mp3 content that otherwise would
+        // mistakenly lead to us identifying the entire file as a .mp3 file.
+        *confidence = 0.31;
+
+        return true;
+    } 
+
+    return false;
+}
+
+}
+
diff --git a/media/libstagefright/MediaDefs.cpp b/media/libstagefright/MediaDefs.cpp
index bdb8d44..9e1707f 100644
--- a/media/libstagefright/MediaDefs.cpp
+++ b/media/libstagefright/MediaDefs.cpp
@@ -52,7 +52,7 @@ const char *MEDIA_MIMETYPE_CONTAINER_MATROSKA = "video/x-matroska";
 const char *MEDIA_MIMETYPE_CONTAINER_MPEG2TS = "video/mp2ts";
 const char *MEDIA_MIMETYPE_CONTAINER_AVI = "video/avi";
 const char *MEDIA_MIMETYPE_CONTAINER_MPEG2PS = "video/mp2p";
-
+const char *MEDIA_MIMETYPE_CONTAINER_FLV = "video/flv";
 const char *MEDIA_MIMETYPE_CONTAINER_WVM = "video/wvm";
 
 const char *MEDIA_MIMETYPE_TEXT_3GPP = "text/3gpp-tt";
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index 9ab6611..60850a9 100644
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -14,11 +14,12 @@
  * limitations under the License.
  */
 
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 #define LOG_TAG "MediaExtractor"
 #include <utils/Log.h>
 
 #include "include/AMRExtractor.h"
+#include "include/AVIExtractor.h"
 #include "include/MP3Extractor.h"
 #include "include/MPEG4Extractor.h"
 #include "include/WAVExtractor.h"
@@ -29,6 +30,7 @@
 #include "include/WVMExtractor.h"
 #include "include/FLACExtractor.h"
 #include "include/AACExtractor.h"
+#include "include/FLVExtractor.h"
 
 #include "matroska/MatroskaExtractor.h"
 
@@ -109,9 +111,13 @@ sp<MediaExtractor> MediaExtractor::Create(
         ret = new MatroskaExtractor(source);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2TS)) {
         ret = new MPEG2TSExtractor(source);
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_AVI)) {
+        ret = new AVIExtractor(source);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WVM)) {
         // Return now.  WVExtractor should not have the DrmFlag set in the block below.
         return new WVMExtractor(source);
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_FLV)) {
+        ret = new FLVExtractor(source);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC_ADTS)) {
         ret = new AACExtractor(source, meta);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2PS)) {
diff --git a/media/libstagefright/include/AVIExtractor.h b/media/libstagefright/include/AVIExtractor.h
index ff5dcb5..5a537d6 100644
--- a/media/libstagefright/include/AVIExtractor.h
+++ b/media/libstagefright/include/AVIExtractor.h
@@ -25,6 +25,12 @@
 
 namespace android {
 
+//for broken files, cannot get samplesize
+#define AVI_VIDEO_SAMPLE_MAX_SIZE (192<<10)
+#define AVI_AUDIO_SAMPLE_MAX_SIZE (12 <<10)
+
+
+
 struct AVIExtractor : public MediaExtractor {
     AVIExtractor(const sp<DataSource> &dataSource);
 
@@ -37,6 +43,8 @@ struct AVIExtractor : public MediaExtractor {
 
     virtual sp<MetaData> getMetaData();
 
+    virtual uint32_t flags() const;
+
 protected:
     virtual ~AVIExtractor();
 
@@ -47,6 +55,7 @@ struct AVIExtractor : public MediaExtractor {
     struct SampleInfo {
         uint32_t mOffset;
         bool mIsKey;
+        uint32_t mLengthTotal;
     };
 
     struct Track {
@@ -72,10 +81,26 @@ struct AVIExtractor : public MediaExtractor {
         ssize_t mThumbnailSampleIndex;
         size_t mMaxSampleSize;
 
+        // if no index
+        uint32_t mCurSamplePos;
+
         // If mBytesPerSample > 0:
         double mAvgChunkSize;
         size_t mFirstChunkSize;
+
+        //for avi seeking
+        size_t mPreChunkSize;
+        uint32_t mLengthTotal;
+
+        //bits per sample for pcm
+        size_t mBitsPerSample;
     };
+    enum IndexType
+        {
+            IDX1,        //avi1.0 index
+            INDX,        //Open-DML-Index-chunk
+            NO_INDEX     //normally no idx1, since indx is stored  with a/v data together
+        }mIndexType;
 
     sp<DataSource> mDataSource;
     status_t mInitCheck;
@@ -88,7 +113,8 @@ struct AVIExtractor : public MediaExtractor {
     ssize_t parseChunk(off64_t offset, off64_t size, int depth = 0);
     status_t parseStreamHeader(off64_t offset, size_t size);
     status_t parseStreamFormat(off64_t offset, size_t size);
-    status_t parseIndex(off64_t offset, size_t size);
+    status_t parseIdx1(off64_t offset, size_t size);
+    status_t parseIndx(off64_t offset, size_t size);
 
     status_t parseHeaders();
 
diff --git a/media/libstagefright/include/FLVExtractor.h b/media/libstagefright/include/FLVExtractor.h
new file mode 100644
index 0000000..667018b
--- /dev/null
+++ b/media/libstagefright/include/FLVExtractor.h
@@ -0,0 +1,239 @@
+/**
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLV_EXTRACTOR_H_
+
+#define FLV_EXTRACTOR_H_
+
+#include <media/stagefright/foundation/ABase.h>
+#include <media/stagefright/MediaExtractor.h>
+#include <media/stagefright/MediaSource.h>
+#include <utils/Vector.h>
+
+namespace android {
+
+#define SIZE_OF_TAG_HEAD	11
+
+#define AV_TIME_BASE		1000000
+
+#define AMF_END_OF_OBJECT       0x09
+
+#define FLV_AUDIO_CODECID_MASK		0xf0	//--bit[7:4]
+#define FLV_AUDIO_CODECID_OFFSET	4
+#define FLV_AUDIO_RATE_MASK		0x0c	//--bit[3:2]
+#define FLV_AUDIO_RATE_OFFSET		0x02
+#define FLV_AUDIO_SIZE_MASK		0x02	//--bit1
+#define FLV_AUDIO_CHANNEL_MASK		0x01	//--bit0
+
+#define FLV_VIDEO_FRAMETYPE_MASK	0xf0
+#define FLV_VIDEO_FRAMETYPE_OFFSET  	4
+
+#define FLV_MOVIE_TIMESCALE 1000000
+
+enum {
+    FLV_HEADER_FLAG_HASVIDEO = 1,
+    FLV_HEADER_FLAG_HASAUDIO = 4,
+};
+
+enum {
+    FLV_TAG_TYPE_AUDIO = 0x08,
+    FLV_TAG_TYPE_VIDEO = 0x09,
+    FLV_TAG_TYPE_META  = 0x12,
+};
+
+enum {
+    FLV_CODECID_PCM_BE              = 0,
+    FLV_CODECID_ADPCM               = 1 << FLV_AUDIO_CODECID_OFFSET,
+    FLV_CODECID_MP3                 = 2 << FLV_AUDIO_CODECID_OFFSET,
+    FLV_CODECID_PCM_LE              = 3 << FLV_AUDIO_CODECID_OFFSET,
+    FLV_CODECID_NELLYMOSER_8HZ_MONO = 5 << FLV_AUDIO_CODECID_OFFSET,
+    FLV_CODECID_NELLYMOSER          = 6 << FLV_AUDIO_CODECID_OFFSET,
+    FLV_CODECID_AAC                         = 10 << FLV_AUDIO_CODECID_OFFSET,
+};
+
+enum{
+	FLV_AUDIO_RATE_5500		= 0,
+	FLV_AUDIO_RATE_11000	= 1 << FLV_AUDIO_RATE_OFFSET,
+	FLV_AUDIO_RATE_22000	= 2 << FLV_AUDIO_RATE_OFFSET,
+	FLV_AUDIO_RATE_44000	= 3 << FLV_AUDIO_RATE_OFFSET,
+};
+
+enum {
+    FLV_CODECID_H263    = 2,
+    FLV_CODECID_SCREEN  = 3,
+    FLV_CODECID_VP6     = 4,
+    FLV_CODECID_VP6A    = 5,
+    FLV_CODECID_SCREEN2 = 6,
+    FLV_CODECID_AVC = 7
+};
+
+enum {
+    FLV_FRAME_KEY        = 1 << FLV_VIDEO_FRAMETYPE_OFFSET,
+    FLV_FRAME_INTER      = 2 << FLV_VIDEO_FRAMETYPE_OFFSET,
+    FLV_FRAME_DISP_INTER = 3 << FLV_VIDEO_FRAMETYPE_OFFSET,
+};
+
+typedef enum {
+    AMF_DATA_TYPE_NUMBER      = 0x00,
+    AMF_DATA_TYPE_BOOL        = 0x01,
+    AMF_DATA_TYPE_STRING      = 0x02,
+    AMF_DATA_TYPE_OBJECT      = 0x03,
+    AMF_DATA_TYPE_NULL        = 0x05,
+    AMF_DATA_TYPE_UNDEFINED   = 0x06,
+    AMF_DATA_TYPE_REFERENCE   = 0x07,
+    AMF_DATA_TYPE_MIXEDARRAY  = 0x08,
+    AMF_DATA_TYPE_ARRAY       = 0x0a,
+    AMF_DATA_TYPE_DATE        = 0x0b,
+    AMF_DATA_TYPE_UNSUPPORTED = 0x0d,
+} AMFDataType;
+
+typedef struct FLV_TAG_INFORMATION_TAG
+{
+    uint32_t tag_type;		//--type of cur-packet.
+    uint32_t time_stamp;	//--time stamp of cur-packet in ms.
+    uint32_t data_size;		//--size of the data.
+    uint32_t cur_pos;		//--pos of current packet in file.
+    uint32_t next_pos;		//--pos of next packet in file.
+    uint32_t pre_pos;		//--pos of previous packet in file.
+
+    union TAG_DATA_HEADER_TAG
+    {
+        unsigned char data_head;
+        unsigned char audio_format;		//audio data head.
+        unsigned char video_format;		//video data head.
+        unsigned char object_name_type;	//object data head.
+        uint32_t reserve4B;
+    }data_header;
+
+}FLV_TAG_INFO_T;
+
+// Keyframe Link List
+typedef struct TKeyFrameLinkListItem_TAG
+{
+    uint32_t pos;	//position
+    uint32_t timestamp;//double timestamp;
+    struct TKeyFrameLinkListItem_TAG* next;
+}TKeyFrameLinkListItem_T;
+
+//for broken files, cannot get tagsize
+#define FLV_VIDEO_TAG_MAX_SIZE (384<<10)
+#define FLV_AUDIO_TAG_MAX_SIZE (12 <<10)
+
+struct FLVExtractor : public MediaExtractor {
+    FLVExtractor(const sp<DataSource> &dataSource);
+
+    virtual size_t countTracks();
+
+    virtual sp<MediaSource> getTrack(size_t index);
+
+    virtual sp<MetaData> getTrackMetaData(
+            size_t index, uint32_t flags);
+
+    virtual sp<MetaData> getMetaData();
+
+    virtual uint32_t flags() const;
+
+protected:
+    virtual ~FLVExtractor();
+
+private:
+    struct FLVSource;
+    struct AudioSource;
+
+    struct TagInfo {
+        uint32_t mOffset;
+        bool mIsKey;
+    };
+
+    struct Track {
+        sp<MetaData> mMeta;
+        Vector<TagInfo> mTags;
+        uint32_t mRate;
+        uint32_t mScale;
+
+        // If bytes per tag == 0, each chunk represents a single tag,
+        // otherwise each chunk should me a multiple of bytes-per-tag in
+        // size.
+        uint32_t mBytesPerTag;
+
+        enum Kind {
+            AUDIO,
+            VIDEO,
+            OTHER
+        } mKind;
+
+        size_t mNumSyncTags;
+        size_t mThumbnailTagSize;
+        ssize_t mThumbnailTagIndex;
+        size_t mMaxTagSize;
+
+        // if no index
+        uint32_t mCurTagPos;
+
+        // If mBytesPertag > 0:
+        double mAvgTagSize;
+        size_t mFirstTagSize;
+    }; 
+
+    sp<DataSource> mDataSource;
+    status_t mInitCheck;
+    Vector<Track> mTracks;
+
+    off64_t mMovieOffset;
+    bool mFoundIndex;
+    bool mOffsetsAreAbsolute;
+
+    status_t parseHeaders();
+    status_t parseTagHeaders(off64_t offset, off64_t size);    
+    status_t parseTag(off_t offset, off64_t size, int depth = 0);
+    ssize_t flv_read_metabody(off_t offset);
+    ssize_t amf_get_string(uint32_t offset, uint8_t *buffer, int32_t buffsize);
+    ssize_t amf_parse_object(const char *key, uint32_t  offset, int depth);
+
+
+    status_t getTagInfo(
+            size_t trackIndex, size_t tagIndex,
+            off64_t *offset, size_t *size, bool *isKey,
+            int64_t *tagTimeUs);
+
+    status_t getTagTime(
+            size_t trackIndex, size_t tagIndex, int64_t *tagTimeUs);
+
+    status_t getTagIndexAtTime(
+            size_t trackIndex,
+            int64_t timeUs, MediaSource::ReadOptions::SeekMode mode,
+            size_t *tagIndex) const;
+
+    status_t addMPEG4CodecSpecificData(size_t trackIndex);
+    status_t addH264CodecSpecificData(size_t trackIndex);
+
+    static bool IsCorrectTagType(
+        ssize_t trackIndex, Track::Kind kind, uint32_t chunkType);
+
+    DISALLOW_EVIL_CONSTRUCTORS(FLVExtractor);
+};
+
+class String8;
+struct AMessage;
+
+bool SniffFLV(
+        const sp<DataSource> &source, String8 *mimeType, float *confidence,
+        sp<AMessage> *);
+
+}  // namespace android
+
+#endif  // FLV_EXTRACTOR_H_
+
